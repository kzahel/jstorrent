Below is a **clean, self-contained design document** describing the **io-daemon refresh-config mechanism**, the **updated lifecycle**, and the **interaction between io-daemon and native-host**.
It is written to fit naturally alongside your existing DESIGN.md (same tone, same level of precision).

It intentionally **does not** revisit rpc-info details already documented in native-host/DESIGN.md, but explains how io-daemon *uses* that file and how it is refreshed.


---

# **JSTorrent IO-Daemon — Configuration Refresh Design**

## 1. Overview

The `jstorrent-io-daemon` process is responsible for handling networking and filesystem operations on behalf of the Chrome extension’s BitTorrent engine.
The daemon’s behavior is influenced by metadata stored in `rpc-info.json`, specifically:

* The installation’s `install_id`
* The list of permitted download roots
* Additional future per-installation metadata

This document describes how:

* io-daemon loads this configuration
* io-daemon refreshes it at runtime
* native-host coordinates changes by calling a single refresh endpoint

This design maintains strict separation:

* **native-host** is the *only writer* of rpc-info.json
* **io-daemon** is a *read-only consumer*

---

## 2. Goals

* Allow io-daemon to re-load configuration from `rpc-info.json` whenever the native-host updates it.
* Keep the mechanism **simple, reliable, and idempotent**.
* Reuse io-daemon’s **existing initialization codepath** for loading configuration.
* Avoid introducing new bidirectional protocol layers or IPC systems.
* Keep the native-host in control of when refreshes occur.
* Make the mechanism tolerant of race conditions (multiple refresh triggers, extension-initiated refreshes, etc.)

---

## 3. Startup Lifecycle

### 3.1 Launch by native-host

Native-host launches io-daemon with:

* `--install-id <id>`
* Any other required arguments (logging, debug flags, port=0)

No download roots or tokens are passed as command-line arguments.

### 3.2 Bind ephemeral port

io-daemon binds using port `0`, then prints a single JSON object to stdout, containing:

```
{
  "port": <bound_port>,
  "token": <daemon_token>
}
```

The daemon token is **generated by io-daemon** and is used by native-host to authenticate refresh requests.

### 3.3 Initial configuration load

After binding its port, io-daemon performs:

```
load_rpc_info()
  → locate entry matching install_id
  → load download_roots[]
  → cache all relevant metadata
```

This is the **same codepath** that will later be used on refresh.

### 3.4 Ready state

After loading configuration, io-daemon begins serving:

* WebSocket for socket operations
* HTTP filesystem endpoints
* **The new refresh endpoint** (see below)

At this point, native-host receives the port/token and can forward these to the extension.

---

## 4. Refresh Mechanism

### 4.1 New Endpoint

io-daemon exposes a single endpoint:

```
POST /api/read-rpc-info-from-disk
Authorization: Bearer <daemon_token>
```

Payload may be empty (`{}`) or omitted entirely.

### 4.2 Behavior

Upon receiving a valid request:

1. io-daemon calls the same function used during startup:

```
reload_config_from_rpc_info()
```

2. It:

   * Re-reads `rpc-info.json`
   * Finds the entry matching `install_id`
   * Loads updated metadata (e.g., new or removed download roots)
   * Replaces its internal configuration state

3. Responds with:

```
200 OK
{}
```

### 4.3 Idempotency

Calling the endpoint repeatedly results in the same behavior:

* Always re-reads the entire file
* Always replaces internal state with the file’s latest contents
* No partial merges or deltas

This makes the system robust under:

* Multiple refresh calls in quick succession
* Refresh calls initiated by the extension
* Refresh calls triggered during races with atomic file writes

---

## 5. Native-Host Responsibilities

### 5.1 Updating configuration

When user actions or system events modify the installation's configuration:

* Selecting a new download root
* Removing an existing root
* Regenerating root tokens
* Updating metadata (root status, removable flag, etc.)

native-host must:

1. Load `rpc-info.json`
2. Update the entry matching its install_id
3. Write the file atomically

### 5.2 Triggering refresh

Immediately after atomic write:

```
POST http://127.0.0.1:<daemon_port>/api/read-rpc-info-from-disk
Authorization: Bearer <daemon_token>
```

This instructs io-daemon to reload configuration.

Native-host is the **primary source of refresh events**, and is responsible for maintaining daemon state consistency.

---

## 6. Extension Behavior

The extension is allowed (though not required) to call:

```
POST /api/read-rpc-info-from-disk
```

without knowing the daemon token.

Such a request will be rejected unless it includes the valid daemon token.
However, even if the extension *did* supply the token (e.g., internal testing), configuration would simply be reloaded—an idempotent and safe operation.

There is no harm in extension-initiated refreshes.

---

## 7. Error Handling

### 7.1 Invalid token

Return:

```
401 Unauthorized
```

### 7.2 rpc-info.json missing or corrupted

io-daemon:

* Logs error
* Keeps previous state
* Returns a 500 response

Native-host will recreate missing files as needed.

### 7.3 Unknown install_id

If rpc-info.json does not contain the daemon’s `install_id`, io-daemon:

* Does not replace its internal state
* Logs a warning
* Returns a 404-like failure code (implementation preference)
* Waits for native-host to update the file and retry

---

## 8. Future Extensions

This refresh mechanism is intentionally minimal and extensible.
Future metadata expansions may include:

* Per-installation cache directories
* Configurable runtime behavior flags
* Additional root metadata (filesystem UUID, mount info)
* io-daemon log levels or diagnostics settings
* Security policies for allowed operations

All such data will be communicated solely by updating rpc-info.json and triggering a refresh.

---

## 9. Summary

This design adds:

* A simple, authenticated refresh endpoint in io-daemon
* A unified configuration reload path
* A minimal lifecycle for native-host-triggered refreshes

Key properties:

* No new IPC channels
* No incremental diffs
* Atomic write + full reload = guaranteed consistency
* Extension can trigger harmless re-reads
* io-daemon remains read-only with respect to configuration
* Minimal code addition; high reliability
